---
layout:     post
title:      "C++ 面向对象高级编程（下）"
subtitle:   "C++ OOP Part2"
date:       2019-03-10
author:     "TXXT"
catalog:    true
tags:
    - C++
---

## 转换函数

一般用 `operator type()` 

![1552227946978](/img/in-post/CPP面向对象高级编程下.assets/1552227946978.png)

转换函数的意思就是当系统想把我这个类转换为特定类型时进行的操作，比如图中的例子就是允许把分数转换为 double，当进行double转换时就会调用这个函数。

注意：转换函数不用return type，但需要**operator**和**函数名称**，而且 **通常** 要加上const。

在上面的例子中，当执行到 4+f 时，编译器首先尝试去找有没有类自己定义的操作符函数（+），显然这里没找到，所以这条路线不通。然后编译器会尝试把 f 转换为double，所以找到了这样的一个黄色标识的转换函数，并且执行它。

总结：转换函数很重要，没有转换函数就会报告如下错误：`No viable conversion from 'Fraction' to 'double'`

## 智能指针 (像指针的类)

![1552233366544](/img/in-post/CPP面向对象高级编程下.assets/1552233366544.png)

可以允许多个指针指向同一个对象，定义在 <memory> 中，提供了引用计数，知道还有多少个智能指针指向了这个对象。

上图是一个旧版本的智能指针的基本实现。(其中必定带一个裸指针)

但是上面的蓝色的 -> 已经被作用掉了，被消耗了，怎么下面还有一个 -> ？因为 -> 有一个特殊的行为，就是C++规定 -> 可以一直递归作用下去。

## 迭代器

行为也像一个“智能指针”。里面的实现多了一些，比如“++”、“--”等自增自减操作，一般指针也不需要的。

![1552234423882](/img/in-post/CPP面向对象高级编程下.assets/1552234423882.png)

上图最难的是 `ite->method()` 的时候，执行的具体过程左图有解释。

> 上面两个主题都是用 class 模拟 pointer。

## 仿函数（用class做一个函数）

加入小括号的操作符函数。

有些功能实现的代码，会不断的在不同的成员函数中用到，但是又不好将这些代码独立出来成为一个类的一个成员函数。但是又很想复用这些代码。

1）**公共的函数**，可以，这是一个解决方法；不过函数用到的一些变量，就可能成为公共的全局变量，再说为了复用这么一片代码，就要单立出一个函数，也不是很好维护。

 2）**仿函数**，写一个简单类，除了那些维护一个类的成员函数外，就只是实现一个operator()，在类实例化时，就将要用的，非参数的元素传入类中。

## namespace

将各个东西区分开来，适合于团队之间解决冲突之类的。取个名字把那些东西包起来。

## class template

![1552280121783](/img/in-post/CPP面向对象高级编程下.assets/1552280121783.png)

把类型名抽出来通用。(泛型编程)

## function template

因为编译器会对函数进行实参推导，所以在使用函数模板的时候，不用放进去<typename> 说这个类型是什么。

![1552280346648](/img/in-post/CPP面向对象高级编程下.assets/1552280346648.png)

## 模板特化

针对模板传入的不同类型进行不同的处理

![1552281073113](/img/in-post/CPP面向对象高级编程下.assets/1552281073113.png)

比如上面的使用中，`hash<long>() (1000)` 用的就是最下面的特化的例子，第一个（）是为了启动一个临时对象，然后（）操作符函数会对1000两边的操作符操作。

> 图里第一个框框就是“泛化”，第二个框框就是“特化”



（跳过一部分模板高级内容）



## auto (c++11)

![1552281782119](/img/in-post/CPP面向对象高级编程下.assets/1552281782119.png)

auto让编译器自动推导。一个语法糖。但也不是说所有地方都用auto。

## ranged-base for (c++11)

![1552282077317](/img/in-post/CPP面向对象高级编程下.assets/1552282077317.png)

前者是copy动作，后者是reference动作。

## reference

![1552283179394](/img/in-post/CPP面向对象高级编程下.assets/1552283179394.png)

引用的表现和指针类似。

引用通常用于函数参数传递。

## 对象模型



#### 虚指针vptr 和 虚表vtbl

![1552284239158](/img/in-post/CPP面向对象高级编程下.assets/1552284239158.png)

带有虚函数的对象里面都还有一个指针 `vptr` 指向一个虚表。所以继承的父类有虚函数，那么子类里一定也有虚函数。图中左边的表格就是三个对象里存的内容。

继承函数继承的是 **调用权**，而非大小。

这里函数调用和正常的静态绑定（编译时直接绑定，汇编语言中就是 CALL XXXX），在虚函数中，使用的是动态绑定，在运行时查找虚表来找到对应的函数实现。或者说当用指针的时候，且这个时候需要向上转型（比如new了一个🐖，但是用的动物指针调用了方法，这个就叫向上转型），就要动态绑定了。



#### this指针

![1552312616384](/img/in-post/CPP面向对象高级编程下.assets/1552312616384.png)

右下角的图中，谁调用这个函数谁是this。所有的成员函数有隐藏的this指针，所以传进去后，函数的所有调用都是按照 this->method() 来调用，找到vtpr，然后就知道调用哪个函数了。

#### 动态绑定

下面 `a.vfunc1()` 是通过对象调用的，不是指针，所以肯定是静态绑定了！

![1552313952764](/img/in-post/CPP面向对象高级编程下.assets/1552313952764.png)

但是这里通过指针，所以通过指针找到 vtpr，然后找到虚表才能找到调用的真正函数。

![1552313941757](/img/in-post/CPP面向对象高级编程下.assets/1552313941757.png)

## Const

对于成员函数，可以放在函数参数列表后面。

![1552314638689](/img/in-post/CPP面向对象高级编程下.assets/1552314638689.png)

所以记得 const ！

