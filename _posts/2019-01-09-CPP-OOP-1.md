---
layout:     post
title:      "C++ 面向对象高级编程（上）"
subtitle:   "C++ OOP Part1"
date:       2019-01-09
author:     "TXXT"
catalog:    true
tags:
    - C++
---

> 本学习笔记不可替代 《C++ Primer》
>
> 感谢侯捷老师的点拨

# 第一天

第一周的例子是不带指针的对象

## C vs. C++ （数据和函数）

![1546573936052](/img/in-post/CPP面向对象高级编程上.assets/1546573936052.png)

C中，函数处理任意的数据，数据没所有权，有问题存在；C++中带来了对象，将数据和函数绑定。



**Object Based: **面对的是单一class的设计

**Object Oriented: ** 面对的是多重classes的设计



## C++ programs 基本形式

![1546574075326](/img/in-post/CPP面向对象高级编程上.assets/1546574075326.png)

注：引用C语言头文件的话，加一个 "c"，eg：<cstdio>



## C++ Header

#### Header中的防卫式声明

![1546574222630](/img/in-post/CPP面向对象高级编程上.assets/1546574222630.png)

这是为了避免重复定义

#### Header的布局

![1546574302056](/img/in-post/CPP面向对象高级编程上.assets/1546574302056.png)

## Class template 简介

因为多个类之间可能只有些许的差别，比如数据的类型一个是int一个是double，但为此就要分别设计两个类，太麻烦，所以C++引入了模板。

![1546574691592](/img/in-post/CPP面向对象高级编程上.assets/1546574691592.png)

类的头部上面加入黄色部分，意思说我在后来才说明T是个什么，第二个框就是个用法。



## inline 函数

这个函数比较快，告诉编译器而已，并不是一定变成inline。

注意：函数若在 class body 内定义完成，变自动成inline函数。



## access level

class 默认是private，struct 默认是public。**一般情况**，函数放在public，而数据放在private。

![1546670835419](/img/in-post/CPP面向对象高级编程上.assets/1546670835419.png)



## Constructor （构造函数）

函数名和类名相同，创建对象时自动执行的（无法手动执行）。

它可以有默认实参（default argument），例子在上图，默认都是 0。

它可以有初始化列表（initialization list）。相比在大括号赋值更快，因为先初始化再赋值，初始化列表相当于在初始化的时候直接就设定初值。

没有返回类型。

#### Constructor可以有多个重载

在C++中函数名相同，不代表编译器看见的也是一样，因此这就是函数重载的机遇

但是以下的这种同名不允许，会迷惑编译器：

![1546672141593](/img/in-post/CPP面向对象高级编程上.assets/1546672141593.png)

#### Constructor一般放在public

放在private代表这个类不允许被外界所创建。

但是确实有这种需求，比如 singleton，表示最多创建一份对象，这样的话只能这样写：

![1546672440136](/img/in-post/CPP面向对象高级编程上.assets/1546672440136.png)

#### const member functions （常量成员函数）

表示不改变类中成员变量的内容。

下面的例子中，右手边的用法 **可能** 有问题，当类中没加 const，那么调用就错了，因为 `const complex c1(2,1)` 表示里面的成员变量都不能动，但是没加const的函数编译器认为里面可能会改变成员变量，所以报错！不过调用的 real 和 imag 函数加了const就没问题啦！

总结：应该加 const 的就要加上，不然可能有问题！

![1546672625526](/img/in-post/CPP面向对象高级编程上.assets/1546672625526.png)

## 参数传递（值 or 引用）

引用在底部实现就是指针，但是它不是按照C语言那种指针表示的形式，更加漂亮。

所以参数传递尽量考虑传引用，如果只是为了传递速度，不希望被改前面加 const (这个看情况)。

## 返回值传递（值 or 引用）

和参数一样，尽量return by reference。（前提是适合用引用的情况）

PS：但是一种情况，就是函数里创建的内容，你传出去引用，那么函数结束的时候，它的生命周期就到了，内容就被清空。除此之外都可以返回引用。

![1546674548327](/img/in-post/CPP面向对象高级编程上.assets/1546674548327.png)

## friend（友元）

友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明。

PS：相同 class 的各个 objects 默认互为 friends （看起来打破了封装性，）



## 操作符重载

C++里，操作符某个意义就是函数。这个语言允许你改变操作符定义。

![1546682193944](/img/in-post/CPP面向对象高级编程上.assets/1546682193944.png)

上图中的例子说明，操作符左边是作用的对象，所以this指代了左边的c2。那么左小图中就没有this指针出现（不能按照下图那样显示写出this，每一个成员函数默认都有this）。

#### <<重载

ostream不能const，因为这个状态一直在变化。

![1546694438208](/img/in-post/CPP面向对象高级编程上.assets/1546694438208.png)

## 临时对象

- 下面的例子中，不能返回引用。因为这次不是说加到某一个对象上，因此这个对象是新建立的，如果返回引用，那么函数结束后，对象就死亡了。

- 临时对象是 typename + () ，意思就是生命周期很短，下一行就结束了。例子中为了返回就用临时对象，反正后面也不用了。

![1546692344207](/img/in-post/CPP面向对象高级编程上.assets/1546692344207.png)

## 小结

- 初始化列表
- 函数要不要加const
- 参数的传递尽量考虑 pass by reference
- 数据一般放在private，函数一般放在public



# 第二天

之前只考虑不带指针成员的类，比如 Complex，现在考虑带指针成员的类，比如 string。

编译器默认会有一个拷贝构造和拷贝赋值函数给类，但是这个是一个个字节拷贝过去，对于没有指针的类，这样 very nice。不过有指针后，把同一个指针拷贝过去或许不是我们想要的，因此需要自己实现这个函数。

## 拷贝构造/赋值

![1546772396511](/img/in-post/CPP面向对象高级编程上.assets/1546772396511.png)

第一个：普通的构造函数；
第二个：拷贝构造函数；
第三个：=号的操作符重载，是拷贝赋值；
第四个：析构函数，没有的话会自动有一个默认析构函数
第五个：输出函数

![1546783425638](/img/in-post/CPP面向对象高级编程上.assets/1546783425638.png)

- 输出函数返回的就是字符指针给 ostream

- 意思就是带有指针的成员的类，要有拷贝构造和拷贝赋值的动作。

**注意：**如果没有拷贝赋值，比如两个string类。b = a，那么b之前的内容就成孤儿了，因为相当于b的指针和a相同，其实b的指针指向的内容并没有释放。

#### 拷贝赋值

![1546782776664](/img/in-post/CPP面向对象高级编程上.assets/1546782776664.png)

- 拷贝赋值要先杀掉自己的空间，然后创建一个空间，然后才拷贝。
- operator=中检查自我赋值很重要！！！

#### 拷贝构造

![1546782793878](/img/in-post/CPP面向对象高级编程上.assets/1546782793878.png)



## 构造和析构

PS：对于c/c++，字符串的结束符号在最后。、

- class 里有指针，多半要动态分配，如下图
- 动态分配的东西死亡前，要主动析构掉

下面那个下图中，有三个字符串，s1和s2离开的时候自动执行析构函数，当然delete p的时候也会执行。

array new 要搭配 array delete！

![1546781817424](/img/in-post/CPP面向对象高级编程上.assets/1546781817424.png)

## Stack Heap

**Stack: **存在于某个作用域（Scope）的一个内存空间。

函数本体内声明的任何变量，所使用的内存区都取自上述stack

**Heap: **程序可以动态分配的东西存在的地方。



#### auto objects

存在栈中的，如果作用域结束就自动执行析构。

#### static objects

即使在某个作用域，其生命周期也不受影响，可以在全局存在。

#### global objects

和上面的差不多



## New

对于没有指针的那种类：

![1546784531377](/img/in-post/CPP面向对象高级编程上.assets/1546784531377.png)

对于带指针的类：

![1546784560840](/img/in-post/CPP面向对象高级编程上.assets/1546784560840.png)

## 动态分配的内存块

![1546785376533](/img/in-post/CPP面向对象高级编程上.assets/1546785376533.png)

对于Complex类，这是分配的对应内存块。可以看到两边分别一个cookie夹住，16字节十六进制就是0x10，最后一位为1表示这个内存块被分配出去了。

![1546785387950](/img/in-post/CPP面向对象高级编程上.assets/1546785387950.png)

对于String类，只有一个指针，因此总共12字节，但是！编译器在编译malloc的时候需要内存对齐，最小单位是16字节，所以不够的也要凑够。

## 动态分配所得的array

```c++
Complex *p = new Complex[3]
```

![1546786155926](/img/in-post/CPP面向对象高级编程上.assets/1546786155926.png)

```c++
String *p = new String[3]
```

![1546786183588](/img/in-post/CPP面向对象高级编程上.assets/1546786183588.png)

为什么多加了一个4？因为在VC编译器中，用一个整数来表示数组的size大小。(不过没有标准这么定义，不同的编译器允许有其它的实现)

## 那为什么array new搭配array delete？

这一大块内容都是会删除！不管写不写 []。

但是！下面会少调用2次析构函数。

**这种内存泄漏是析构函数的缺少导致的。**

![1546786355424](/img/in-post/CPP面向对象高级编程上.assets/1546786355424.png)

## static

![1546840428978](/img/in-post/CPP面向对象高级编程上.assets/1546840428978.png)

- 调用成员函数的时候其实给了同一个函数不同的对象地址，就是this指针。函数只有一份。

- 静态数据成员，和对象无关，所有对象看到的同一份。

  静态的数据成员在类外要定义才行，因为在类中虽然声明了，但是是脱离了某个对象而存在。

- 静态成员函数脱离了对象，所以只能处理静态的数据。

  当然调用也是可以通过 class name::function name这样用的。

## 类模板

![1546845549346](/img/in-post/CPP面向对象高级编程上.assets/1546845549346.png)

## 函数模板

![1546845585608](/img/in-post/CPP面向对象高级编程上.assets/1546845585608.png)



# 第三天

这里探讨类和类的关系，组合、继承、虚函数、多态、委托设计。

## 1 组合 Composition (has a)

![1546846260647](/img/in-post/CPP面向对象高级编程上.assets/1546846260647.png)

例子中，queue中有一个deque。组合的意思就是：你已经有个功能比较强大的东西，你想稍微改变就形成一个有某些子功能的模块。这就是Adapter，意思就是之前的功能已经很强大，现在稍微改造下接口。

**下图也是一个组合：**

![1546846665625](/img/in-post/CPP面向对象高级编程上.assets/1546846665625.png)

**对于组合的构造和析构：**

![1546846714934](/img/in-post/CPP面向对象高级编程上.assets/1546846714934.png)



## 2 继承 (is a)

![1546847947995](/img/in-post/CPP面向对象高级编程上.assets/1546847947995.png)

比如在例子中，除了base，它还有自己独立的 _M_data。

**继承下的构造和析构**

PS：base class 的析构函数必须是 virtual。

![1546847969182](/img/in-post/CPP面向对象高级编程上.assets/1546847969182.png)

#### 虚函数

- non-virtual：你不希望 derived class 重新定义（override）
- virtual：有默认定义，但是你也希望 derived class 重新定义
- pure virtual：希望 derived class 一定要重新定义，没默认定义

![1546851077761](/img/in-post/CPP面向对象高级编程上.assets/1546851077761.png)

上面的例子中，Serialize() 函数就是虚函数，因为只有应用程序本身知道如何读取自己的文件。

#### 继承+组合 关系下的构造和析构

写了一个小例子，下图是运行内容。

```shell
//shell的输出内容

Base Constructor
Component Constructor
Derive Constructor
Derive Destructor
Component Destructor
Base Destructor
```

下面的图验证了我的例子。

![1546852747982](/img/in-post/CPP面向对象高级编程上.assets/1546852747982.png)

#### 委托+继承

可以实现以下功能，有不同的 observer 来看同一份数据。右边 observer 和左边就是委托的关系。当subject中的data变化，就通知所有的绑定observer去更新数据。

这在UI软件是一个经典实现。

![1546926213028](/img/in-post/CPP面向对象高级编程上.assets/1546926213028.png)

![1546941237325](/img/in-post/CPP面向对象高级编程上.assets/1546941237325.png)



## 3 委托 Delegation

和组合不一样，它们的生命周期不绑定。右边的改动不影响左边。可以实现 **引用计数** 的功能，比如3个 string 对象共享一个"hello"的内容。

> 当然如果a想独自改hello，可以用 **copy on write** 实现，就是单独给一份copy让a来改。

![1546847506586](/img/in-post/CPP面向对象高级编程上.assets/1546847506586.png)

下面考虑一个例子，有一个东西，里面想放两种东西，一个是自己，一个是另外的一种，这两种东西都继承自一个 Component 就解决问题了。（C++容器放的东西大小一样，因此应该放指针，所以变成了委托）。下图就展示了这种用到了继承和委托的设计方法。

![1546941264918](/img/in-post/CPP面向对象高级编程上.assets/1546941264918.png)



下面的例子是 **Prototype** 的设计方法：

![1546958314594](/img/in-post/CPP面向对象高级编程上.assets/1546958314594.png)

背景：需要一个继承体系，但是子类是未来创建的。父类不知道子类是什么。

![1546961735809](/img/in-post/CPP面向对象高级编程上.assets/1546961735809.png)

![1546961749378](/img/in-post/CPP面向对象高级编程上.assets/1546961749378.png)

![1546961757960](/img/in-post/CPP面向对象高级编程上.assets/1546961757960.png)